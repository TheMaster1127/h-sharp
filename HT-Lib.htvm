; global vars NEEDED
int HT_LIB_theIdNumOfThe34 := 0
arr str HT_Lib_theIdNumOfThe34theVar
;;;;;;;;;;;;;;;;;;;;;;;;;;
func str preserveStrings(str code, str keyWordEscpaeChar := "\") {
    arr str getAllCharForTheFurtureSoIcanAddEscapeChar
    str ReplaceFixWhitOutFixDoubleQuotesInsideDoubleQuotes := ""
    str str21 := ""
    str htCodeOUT754754 := ""
    str OutFixDoubleQuotesInsideDoubleQuotes := ""
    int fixOutFixDoubleQuotesInsideDoubleQuotesFIXok := 0
    int removeNexFixkeyWordEscpaeChar := 0
    int areWEinSome34sNum := 0
    Loop, Parse, code {
        HT_Lib_theIdNumOfThe34theVar.add("")
        HT_Lib_theIdNumOfThe34theVar.add("")
    }
    Loop, Parse, code {
        HT_Lib_theIdNumOfThe34theVar[A_Index] := HT_Lib_theIdNumOfThe34theVar[A_Index] . Chr(34)
        getAllCharForTheFurtureSoIcanAddEscapeChar.add(A_LoopField)
    }
    getAllCharForTheFurtureSoIcanAddEscapeChar.add(" ")
    ReplaceFixWhitOutFixDoubleQuotesInsideDoubleQuotes := Chr(34) . "ihuiuuhuuhtheidFor" . str21 . "--" . str21 . "asds" . str21 . "as--" . str21 . "theuhtuwaesphoutr" . Chr(34)
    Loop, Parse, code {
        if (A_LoopField = keyWordEscpaeChar) and (getAllCharForTheFurtureSoIcanAddEscapeChar[A_Index + 1] = Chr(34)) {
            fixOutFixDoubleQuotesInsideDoubleQuotesFIXok := 1
            OutFixDoubleQuotesInsideDoubleQuotes .= ReplaceFixWhitOutFixDoubleQuotesInsideDoubleQuotes
        }
        else {
            if (fixOutFixDoubleQuotesInsideDoubleQuotesFIXok != 1) {
                OutFixDoubleQuotesInsideDoubleQuotes .= A_LoopField
            }
            else {
                fixOutFixDoubleQuotesInsideDoubleQuotesFIXok := 0
            }
        }
    }
    code := OutFixDoubleQuotesInsideDoubleQuotes
    if (keyWordEscpaeChar != Chr(92)) {
        code := StrReplace(code, Chr(92), Chr(92) . Chr(92))
    }
    if (keyWordEscpaeChar = Chr(92)) {
        Loop, Parse, code {
            if (A_LoopField = Chr(34)) {
                areWEinSome34sNum++
            }
            if (areWEinSome34sNum = 1) {
                if (A_LoopField != Chr(34)) {
                    if (A_LoopField = keyWordEscpaeChar) {
                        HT_Lib_theIdNumOfThe34theVar[HT_LIB_theIdNumOfThe34] := HT_Lib_theIdNumOfThe34theVar[HT_LIB_theIdNumOfThe34] . Chr(92)
                    }
                    else {
                        HT_Lib_theIdNumOfThe34theVar[HT_LIB_theIdNumOfThe34] := HT_Lib_theIdNumOfThe34theVar[HT_LIB_theIdNumOfThe34] . A_LoopField
                    }
                }
                else {
                    HT_LIB_theIdNumOfThe34++
                    htCodeOUT754754 .= "VYIGUOYIYVIUCFCYIUCFCYIGCYGICFHYFHCTCFTFDFGYGFC" . Chr(65) . Chr(65) . STR(HT_LIB_theIdNumOfThe34) . Chr(65) . Chr(65)
                }
            }
            if (areWEinSome34sNum = 2) or (areWEinSome34sNum = 0) {
                if (A_LoopField != Chr(34)) {
                    htCodeOUT754754 .= A_LoopField
                }
                areWEinSome34sNum := 0
            }
        }
    }
    else {
        Loop, Parse, code {
            if (A_LoopField = Chr(34)) {
                areWEinSome34sNum++
            }
            if (areWEinSome34sNum = 1) {
                if (A_LoopField != Chr(34)) {
                    if (A_LoopField = keyWordEscpaeChar) and (keyWordEscpaeChar = getAllCharForTheFurtureSoIcanAddEscapeChar[A_Index + 1]) {
                        HT_Lib_theIdNumOfThe34theVar[HT_LIB_theIdNumOfThe34] := HT_Lib_theIdNumOfThe34theVar[HT_LIB_theIdNumOfThe34] . keyWordEscpaeChar
                        removeNexFixkeyWordEscpaeChar := 1
                    }
                    else if (A_LoopField = keyWordEscpaeChar) {
                        if (removeNexFixkeyWordEscpaeChar != 1) {
                            HT_Lib_theIdNumOfThe34theVar[HT_LIB_theIdNumOfThe34] := HT_Lib_theIdNumOfThe34theVar[HT_LIB_theIdNumOfThe34] . Chr(92)
                        }
                        else {
                            removeNexFixkeyWordEscpaeChar := 0
                        }
                    }
                    else {
                        HT_Lib_theIdNumOfThe34theVar[HT_LIB_theIdNumOfThe34] := HT_Lib_theIdNumOfThe34theVar[HT_LIB_theIdNumOfThe34] . A_LoopField
                    }
                }
                else {
                    HT_LIB_theIdNumOfThe34++
                    htCodeOUT754754 .= "VYIGUOYIYVIUCFCYIUCFCYIGCYGICFHYFHCTCFTFDFGYGFC" . Chr(65) . Chr(65) . STR(HT_LIB_theIdNumOfThe34) . Chr(65) . Chr(65)
                }
            }
            if (areWEinSome34sNum = 2) or (areWEinSome34sNum = 0) {
                if (A_LoopField != Chr(34)) {
                    htCodeOUT754754 .= A_LoopField
                }
                areWEinSome34sNum := 0
            }
        }
    }
    code := htCodeOUT754754
    Loop, % HT_LIB_theIdNumOfThe34 {
        HT_Lib_theIdNumOfThe34theVar[A_Index] := HT_Lib_theIdNumOfThe34theVar[A_Index] . Chr(34)
    }
    HT_Lib_theIdNumOfThe34theVar.add(Chr(34))
    return code
}
;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;
func str restoreStrings(str codeOUT, str keyWordEscpaeChar := Chr(92)) {
    Loop, % HT_LIB_theIdNumOfThe34 {
        if (HT_LIB_theIdNumOfThe34 = A_Index + 1) {
            codeOUT := StrReplace(codeOUT, "VYIGUOYIYVIUCFCYIUCFCYIGCYGICFHYFHCTCFTFDFGYGFC" . Chr(65) . Chr(65) . STR(A_Index + 1) . Chr(65) . Chr(65), StrReplace(HT_Lib_theIdNumOfThe34theVar[A_Index + 1], keyWordEscpaeChar, "\") . Chr(34))
        }
        else {
            codeOUT := StrReplace(codeOUT, "VYIGUOYIYVIUCFCYIUCFCYIGCYGICFHYFHCTCFTFDFGYGFC" . Chr(65) . Chr(65) . STR(A_Index + 1) . Chr(65) . Chr(65), StrReplace(HT_Lib_theIdNumOfThe34theVar[A_Index + 1], keyWordEscpaeChar, "\"))
        }
    }
    return codeOUT
}
func str cleanUpFirst(str code) {
    code := StrReplace(code, Chr(13), "")
    str out := ""
    Loop, Parse, code, `n, `r {
        out .= Trim(A_LoopField) . Chr(10)
    }
    StringTrimRight, out, out, 1
    return out
}




func str getLangParams(str binName, str langExtension, str extra := "") {
    str params := Trim(GetParams())
    str paramsTemp := ""
    
    if (params = "") {    
        if (isWindows()) {
            print("Usage:" . Chr(10) . Trim(binName) . " your_file." . Trim(langExtension) . " " . Trim(extra))
        } else {
            print("Usage:" . Chr(10) . "./" . Trim(binName) . " your_file." . Trim(langExtension) . " " . Trim(extra))
        }
        return ""
    } else {
        return params
    }
    return "MASSIVE ERROR"
}


func void saveOutput(str outCode, str fileName) {
    FileDelete(Trim(fileName))
    FileAppend(Trim(outCode), Trim(fileName))
    print("Generation finished: " . Trim(fileName) . " generated.")
}

func bool beginning(str line, str what) {

if (SubStr(line, 1, StrLen(what)) = what) {
return true
}

return false
}

func str formatCurlyBracesForParsing(str code, str openBrace := "{", str closeBrace := "}") {

code := StrReplace(code, openBrace, Chr(10) . "{" . Chr(10))
code := StrReplace(code, closeBrace, Chr(10) . "}" . Chr(10))
code := cleanUpFirst(code)
return code
}


func str handleComments(str code, str commentKeyword := ";") {
str str1 := ""



Loop, Parse, code, `n, `r {

str1 .= StrSplit(A_LoopField, commentKeyword, 1) . Chr(10)

}


StringTrimRight, code, str1, 1

return code
}




; Define the function to check odd spaces at the beginning
func str CheckOddLeadingSpaces(str string123)
{
; Initialize a variable to count the spaces
int spaceCount := 0

; Loop through the string one character at a time
Loop, Parse, string123
{
; Check if the current character is a space
if (A_LoopField = Chr(32))
{
spaceCount++
}
else
{
; When we hit a non-space character, break the loop
break
}
}

; Return true if the number of spaces is odd, false otherwise
str sdsfawasd := STR(Mod(spaceCount, 2) = 1)
;MsgBox, % sdsfawasd
return sdsfawasd
}



func str RepeatSpaces(int count)
{
str spaces := ""
Loop, % count
{
spaces .= Chr(32)
}
return spaces
}

; if you wanna convert to python, nim etc... indentation style we set modeCurlyBracesOn to 0 
func str indent_nested_curly_braces(str input_string, int modeCurlyBracesOn := 1)
{
int indent_size := 4
int current_indent := 0
str result := ""
str trimmed_line := ""
str resultOut := ""

str culyOpenFix := "{"
str culyCloseFix := "}"


;MsgBox, % input_string
Loop, Parse, input_string, `n, `r
{

trimmed_line := Trim(A_LoopField)

if (trimmed_line = Chr(123))
{

result .= Chr(32) . RepeatSpaces(current_indent) . trimmed_line . Chr(10)
current_indent := current_indent + indent_size
}
else if (trimmed_line = Chr(125))
{

current_indent := current_indent - indent_size
result .= Chr(32) . RepeatSpaces(current_indent) . trimmed_line . Chr(10)
}
else
{

result .= Chr(32) . RepeatSpaces(current_indent) . trimmed_line . Chr(10)
}

}


if (modeCurlyBracesOn = 0)
{
str resultOut := ""
Loop, Parse, result, `n, `r
{
if (Trim(A_LoopField) != "{") and (Trim(A_LoopField) != "}")
{
resultOut .= A_LoopField . Chr(10)
}
}
StringTrimRight, result, resultOut, 1
}
else
{
; format curly braces in a K&R style

arr str lookIntoFurture

Loop, Parse, result, `n, `r
{
lookIntoFurture.add(Trim(A_LoopField))
}
lookIntoFurture.add(" ")

str resultOut := ""
int skipNext := 0
Loop, Parse, result, `n, `r
{


skipNext--
if (skipNext <= 0)
{
skipNext := 0
}
if (Trim(lookIntoFurture[A_Index + 1]) = "{")
{
resultOut .= A_LoopField . " " . culyOpenFix . Chr(10)
skipNext := 2
}

if (skipNext = 0)
{
resultOut .= A_LoopField . Chr(10)
}


}
StringTrimRight, result, resultOut, 1

arr str lookIntoFurture2

Loop, Parse, result, `n, `r
{
lookIntoFurture2.add(Trim(A_LoopField))
}
lookIntoFurture2.add(" ")


resultOut := ""
skipNext := 0
str addSpacesAtTheBegginig
Loop, Parse, result, `n, `r
{
skipNext--
if (skipNext <= 0)
{
skipNext := 0
}


if (Trim(A_LoopField) = "}") and (Trim(lookIntoFurture2[A_Index + 1]) = "else {")
{
skipNext := 2
addSpacesAtTheBegginig := ""
Loop, Parse, A_LoopField
{
if (A_LoopField = " ")
{
if (A_LoopField != " ")
{
break
}
addSpacesAtTheBegginig .= StrReplace(A_LoopField, "}", culyCloseFix)
}
}
resultOut .= addSpacesAtTheBegginig . culyCloseFix . " else " . culyOpenFix . Chr(10)
}



if (skipNext = 0)
{
resultOut .= A_LoopField . Chr(10)
}
}
StringTrimRight, result, resultOut, 1
}


resultOut := ""
str ALoopField
Loop, Parse, result, `n, `r
{
if (CheckOddLeadingSpaces(A_LoopField) = "1")
{
StringTrimLeft, ALoopField, A_LoopField, 1
resultOut .= ALoopField . Chr(10)
}
else
{
resultOut .= A_LoopField . Chr(10)
}
}

StringTrimRight, result, resultOut, 1



; Return the result
return result
}

